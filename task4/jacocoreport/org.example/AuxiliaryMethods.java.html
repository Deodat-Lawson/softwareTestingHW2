<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AuxiliaryMethods.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">softwareTestingHW2</a> &gt; <a href="index.source.html" class="el_package">org.example</a> &gt; <span class="el_source">AuxiliaryMethods.java</span></div><h1>AuxiliaryMethods.java</h1><pre class="source lang-java linenums">package org.example;

import java.util.Arrays;

<span class="nc" id="L5">public class AuxiliaryMethods {</span>

    /** Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go
     * outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.
     *
     * @param x the inout number
     * @return reverse of x
     */
    public static int reverse(int x) {
<span class="nc" id="L14">        int rev = 0;</span>
<span class="nc bnc" id="L15" title="All 2 branches missed.">        while (x &gt; 0) {</span>
<span class="nc" id="L16">            int pop = x % 10;</span>
<span class="nc" id="L17">            x /= 10;</span>
<span class="nc bnc" id="L18" title="All 6 branches missed.">            if (rev &gt; Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7))</span>
<span class="nc" id="L19">                return 0;</span>
<span class="nc bnc" id="L20" title="All 6 branches missed.">            if (rev &lt; Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8))</span>
<span class="nc" id="L21">                return 0;</span>
<span class="nc" id="L22">            rev = rev * 10 + pop;</span>
<span class="nc" id="L23">        }</span>
<span class="nc" id="L24">        return rev;</span>
    }

    /** Given two strings s and t, determine if they are isomorphic.
     * Two strings s and t are isomorphic if the characters in s can be replaced to get t.
     * All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.
     *
     * @param s the first string
     * @param t the second string
     * @return true if s1 and s2 are isomorphic, false otherwise.
     */
    public static boolean isIsomorphic(String s, String t) {

<span class="nc" id="L37">        int[] mappingDictStoT = new int[256];</span>
<span class="nc" id="L38">        Arrays.fill(mappingDictStoT, -1);</span>

<span class="nc" id="L40">        int[] mappingDictTtoS = new int[256];</span>
<span class="nc" id="L41">        Arrays.fill(mappingDictTtoS, -1);</span>

<span class="nc bnc" id="L43" title="All 2 branches missed.">        for (int i = 0; i &lt; s.length(); ++i) {</span>
<span class="nc" id="L44">            char c1 = s.charAt(i);</span>
<span class="nc" id="L45">            char c2 = t.charAt(i);</span>

            // Case 1: No mapping exists in either of the dictionaries
<span class="nc bnc" id="L48" title="All 4 branches missed.">            if (mappingDictStoT[c1] == -1 &amp;&amp; mappingDictTtoS[c2] == -1) {</span>
<span class="nc" id="L49">                mappingDictStoT[c1] = c2;</span>
<span class="nc" id="L50">                mappingDictTtoS[c2] = c1;</span>
            }

            // Case 2: Either mapping doesn't exist in one of the dictionaries or Mapping exists and
            // it doesn't match in either of the dictionaries or both
<span class="nc bnc" id="L55" title="All 4 branches missed.">            else if (!(mappingDictStoT[c1] == c2 || mappingDictTtoS[c2] == c1)) {</span>
<span class="nc" id="L56">                return false;</span>
            }
        }

<span class="nc" id="L60">        return true;</span>
    }

    /**
     * Count odd or positive elements
     *
     * @param x array to search
     * @return count of odd/positive values in x
     * @throws NullPointerException if x is null
     */
    public static int oddOrPos(int[] x) {
<span class="nc" id="L71">        int count = 0;</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">        for (int i = 0; i &lt; x.length; i++) {</span>
<span class="nc bnc" id="L73" title="All 4 branches missed.">            if (x[i] % 2 == 1 || x[i] &gt; 0) {</span>
<span class="nc" id="L74">                count++;</span>
            }
        }
<span class="nc" id="L77">        return count;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>